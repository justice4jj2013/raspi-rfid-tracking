\chapter{Methodology}
\label{ch:methodology}

This project explores the possibility of developing an RFID location sensing system using cost-effective hardware. This chapter details the software engineering tools and mathematical techniques that were employed to achieve this goal.

\section{Project management}

A number of considerations were taken into account when deciding how to manage this project. First, the system operates using a server-client model. This means that different software components are executing on multiple processing nodes. As a result, changes in one node need to be propagated in the whole system ensuring the consistency of the software.  Second, the software implementation is making use of different programming languages, multiple programming libraries, and a database management system. In order to insure an iterative development process, where software components are constructed, debugged, and packaged together, it was decided to use the \textsc{Git} version control system\footnote{\textsc{Git} version control system - \url{http://git-scm.com/}}. This system keeps a distributed repository of all software and database files so that each node stores a copy of not only the whole software system, but also a complete history of changes. In addition, the use of a version control system stimulates the developer to merge a number of important changes into versions of the software. In this way, it becomes easy to track and monitor the project's progress. The source code and documentation were hosted in a private repository on \textsc{GitHub}\footnote{The private project repository - \url{https://github.com/sandio/raspi-rfid-tracking}} with access granted to the people involved in developing and supervising the project.


\section{Software Engineering Practices}

A number of software engineering practices were of significant help when developing the RFID location sensing system. This section presents them and explains the problems that they solve.  

\subsection{Project decomposition}

It would have been a serious challenge to approach the project's task directly. The system consists of pieces of hardware that had to be orchestrated to solve a common problem. Therefore, it was very important to identify the system's components from early on. Hierarchical relationships between these parts were also defined. These steps ensured that the project could be divided into stages in order to systematically solve the main task. Regular deliveries of working components provided a more manageable way of constructing the final solution. For example, the work plan, devised before the start of the project, consisted of the following key activities:

\begin{enumerate}
 	\item Prepare the single-board computers
 	\item Construct functional RFID reader nodes
 	\item Receive information from the active RFID tag
 	\item Establish a network communication between nodes
 	\item Develop the localisation algorithm
 \end{enumerate}

Iterative construction of the system aided the development process. Problems and challenges were appearing gradually which helped solving them one at a time. 

\subsection{Object-oriented design}

This location sensing system is a combination of different software technologies. For instance, the system required an interface between a single-board computer and an RFID receiver. It also required means of communication between processing nodes. Logically, these and other requirements could be grouped into sets of functions, which is a motivation for employing an object-oriented design. This software methodology was used from the beginning of the project. Similar functionality is organised in a class. A class is responsible for all procedures concerning a particular part of the system. As a result, software is split into categories of functions, which makes it easy to address the class in charge of certain functionality.

Another benefit of the object-oriented design is modularity. For example, once input data is collected from all nodes it could be processed by a localisation algorithm in order to estimate the tag's position. Trilateration was chosen as the technique for computing locations. Object-oriented software development provides an easy way to experiment with different algorithms by substituting one class with another.

\subsection{System scalability}

In this project, three single-board computers collaborate by exchanging RFID readings to localise a tagged object. Three reference points are needed in order to use trilateration in two dimensions  \cite{Zhang2009}. Nevertheless, more reader nodes could be used, in case multileration is implemented, to give a better approximation of a tag's position. Another scenario involves nodes disconnecting and later reappearing into the network. These possible cases show the dynamic nature of the system. It could scale up as the system grows but also scale down if a reader node is faulty. This is an important property of the system, which was noted at the start of the project. To ensure scalability of the server-client model, the multi-threading programming model was used. It allows multiple threads to exist within the context of a single process. As a result, the system could concurrently receive RFID measurements from multiple reader nodes, update data structures, and compute the location of the unknown object.

\subsection{Documentation}

Writing documentation was an important part of this project. The source code of the system has been systematically documented throughout the development process. Using the inline comments specifying how the software components work, an Application Programming Interface (API) was constructed using \textsc{Sphinx}\footnote{\textsc{Sphinx} - a Python documentation generator - \url{http://sphinx-doc.org/index.html}}, a \textsc{Python} documentation generator. The API contains specifications of data structures, variables, and functions. It is a valuable source of information that provides a quick reference of how the system's components work and interact with each other. In addition, a manual for future users of the system was written. It gives a quick introduction of how to setup and use the system. The API and user manual can viewed in Appendix \textbf{REF}  \textbf{TODO}.

This project consists of both hardware and software components. In order to clearly understand how hardware components are connected and how software objects interact, a number of diagrams were used in Chapter \textbf{REF} and in the user manual. These diagrams were generated using \textsc{Blockdiag} \footnote{\textsc{Blockdiag} - simple diagram images generator - \url{http://blockdiag.com/en/}} , a diagram image generator written in \textsc{Python}.

\section{Converting RSSI to distance}
\label{sec:rssitodist}

One of the main challenges of this project was to find a reliable way of converting RSSI values into distance from RFID readers to a tag. As discussed in Section \ref{subsec:rsssianddist}, studies have shown that RSSI is not a reliable or accurate measure of distance. Nevertheless, RSSI is one of the main parameters of this system and distance estimation is solely based on it.

\subsection{Free-space Path Loss}

The first attempt to provide a conversion between RSSI and distance was relying on the inverse-square physical law and free-space path loss (FSPL) formula. In free space propagation, electromagnetic waves obey the inverse-square law stating that the intensity of the emitted radiation is inversely proportional to the square of the distance from the source of the emitted radiation \cite[p. 19]{Schlaikjer1962}. This can be expressed as the following relation:

\[ Intensity \propto \frac{1}{distance^{2}} \]

A more complete relationship between signal strength and distance is given by the FSPL formulation. Free-space path loss is the loss in signal strength of an electromagnetic wave propagating through free space without any obstacles \cite{Balanis2012}. FSPL is proportional to the square of both distance and frequency of the radio signal. It can be expressed in terms of decibels given distance in meters and radio frequency in megahertz\footnote{Derivation the dB version of the FSPL equation - \url{http://www.ece.uvic.ca/~peterd/35001/ass1a/node1.html}}: 

\[ FSPL(dB) = 20\log_{10}(d_{meters}) + 20\log_{10}(f_{MHz}) - 27.55 \]
	
Rearranging the terms of the equation to find the distance gives:

\[ d_{meters} = 10^{(FSPL(dB) - 20\log_{10}(f_{MHz}) + 27.55) / 20} \]

Section \ref{subsec:rssiandrss} discussed the relationship between RSSI and received signal strength (RSS). RSSI is a uniteless measurement derived from the values of the RSS. In Section \ref{subsec:receiver}, Figure \ref{fig:rssi} shows the relationship between RSSI and RSS for the RFID receivers used in this project. Consequently, RSSI values can be converted to received signal strength expressed in $dBm$ and inserted into the equation above as $FSPL(dB)$. The frequency of the RFID project hardware is  $315MHz$ (see Table \ref{tbl:reader} and \ref{tbl:tag}).

There are three problems with this approach. First, it models how the signal strength decreases in a line-of-sight propagation in a free from obstacles environments. This project is concerned with location sensing in indoor spaces making the free-space path loss formula inappropriate for this setting. Second, computing the distance for the minimum ($0dB$) and maximum ($60dB$) values of the signal strength range results in distances $0.075$ and $75.716$ meters, which is beyond the practical range of the RFID devices. Third, the conversion from RSSI to RSS might not be appropriate in this case. The RFID equipment for this project is more affordable compared to commercial RFID equipment\footnote{How much do RFID readers cost today? - \url{http://www.rfidjournal.com/faq/show?86}}. As a result, the online support and specifications are scarce, which raises the question to what extend these can be trusted. Moreover, the manufacturer claims a RSSI resolution of 8 bits outputting values between 0 and 255. During the range experiments with this hardware a much smaller resolution was recorded. Consequently, converting RSSI uniteless values to received signal strength in $dBm$ cannot be relied upon. For details on the evaluation of the RFID devices refer to \textbf{REF}. 

\subsection{Translation table}

Rather than relying on the physical relationship between electromagnetic waves and distance, a simpler and more direct approach was taken. For each RFID reader, a translation table was constructed mapping RSSI to distance. According to the manufacturer, but also observed in hardware experiments, reader measurements vary between different devices. There are two reasons for this. First, the RFID readers are hand-made, which introduces small differences in their circuits. Second, the devices are not calibrated to each other when being built.   

The methodology for constructing these translation tables relies entirely on RSSI measurements collected while evaluating the RFID devices. A number of experiments were conducted testing how RSSI changes as the distance between a reader and tag increases. In order to account for the characteristics of indoor environments, these experiments have taken into account the orientation of the tag to the reader, line-of-sight propagation versus obscuring the tag with an obstacle, and elevation of the tag to the reader. Combining measurements from different experiments gives a more realistic representation of how RSSI changes in an indoor environment. Table \ref{tbl:trans} presents the translation table constructed for the first reader. Similar tables were developed for the other two devices (see Appendix \ref{sec:trans}).

\begin{table}[h]
	\centering
	\begin{tabular}{ | c | c | c || c | c || c | c || c | c || c | c || c | c || c | c | }
		\hline
		Distance 	& 0  & 1  & 1  & 2  & 2  & 3  & 3  & 4  & 4  & 5  & 5  & 6  & 6  & 7  \\ \hline
		RSSI 		& 80 & 65 & 64 & 62 & 61 & 57 & 56 & 53 & 52 & 48 & 47 & 46 & 45 & 44  \\ \hline
	\end{tabular}
	\caption{RSSI value ranges used to estimate distance when using the first reader.}
	\label{tbl:trans}
\end{table}

As an example, the first two columns of Table \ref{tbl:trans} have the following meaning. When the reader and tag antennas were touching the average RSSI value from all experiments was 80. When the tag was one meter away from the reader, the average RSSI value of all experiment measurements was 65. RSSI values between 80 and 65 are linearly converted to the new range from 0 to 1 meters as follows: 

\[Old.range = old.min - old.max \\\]
\[New.value = new.min + (old.min - old.value) / old.range\]

An obvious limitation of these conversions is the size of the RSSI ranges. For example, there are 15 possible values that the first reader could measure when the tag is between 0 and 1 meters away from it. In contrast, for a distance between 6 and 7 meters the RSSI values change only by 1 unit. Following from that, the granularity of the distance estimation changes depending on the range of the RSSI measurements. This is caused by a hardware limitation of the readers when measuring RSSI and has been found during the range experiments presented in \textbf{REF}.

There is another factor contributing to the accuracy of this conversion. The RFID tag is using a battery for its power supply. During continuous operation the battery power level gradually drops, thus the tag emits a weaker radio signal as the battery is being depleted. This is reflected in the RSSI measurements making the translation tables inaccurate. In order to account for the RSSI changes, the incoming measurements were increased by an integer factor chosen based on observation. Different factors were selected for each reader due to their measurement differences.

In summary, this conversion method is not universal and probably cannot be applied to other brands of RFID devices. There are numerous factors that contribute to the variations in RSSI such as radio signal reflection, multi-path fading, and shadowing, to name a few. Nevertheless, this method was selected to translate RSSI to distance. Once the translation tables are constructed, it is a matter of calibration. As mentioned above, RSSI to distance conversion is one of the main variables of this system. How these translation tables performed is discussed in Section \textbf{REF}, where the evaluation results of the system in terms of localisation accuracy are presented.


\section{Trilateration}
\label{sec:trilatmeth}


Trilateration is a localisation method computing the position of an unknown object based on range measurements from three reference points at known locations. The concept of this technique was described in Section \ref{sec:trilatback}. This section presents the mathematical technique used in this project that provides an exact and computationally efficient solution for three-dimensional position estimation. The solution is based on the work of Manolakis \cite{Manolakis1996} and the Wikipedia article on trilateration \cite{Wikipedi2013}.

\subsection{Special case}

In three-dimensional Cartesian coordinate system, the equations for three spheres are:
\begin{align*}
	r_1^2 &=(x-x_1)^2+(y-y_1)^2+(z-z_1)^2 \\
	r_2^2 &=(x-x_2)^2+(y-y_2)^2+(z-z_2)^2 \\
	r_3^2 &=(x-x_3)^2+(y-y_3)^2+(z-z_3)^2 \\
\end{align*}
where the sphere centres are ${\bar p}_1 = (x_1, y_1, z_1), \ {\bar p}_2 = (x_2, y_2, z_2), \ {\bar p}_3 = (x_3, y_3, z_3)$ and $r_1$, $r_2$, and $r_3$ are the sphere radii. Solving these equations for $x$, $y$, and $z$ would give their intersection point. However, this is hard to do directly. In order to simplify the calculations, a special case is defined that later can be used as the basis for a general solution. There are three requirements of the special case. First, the three centres of the spheres are on the $z=0$ plane, hence working in two dimensions. Second, one of the centres of the spheres, ${\bar p}_1$, is located at the origin. Third, another centres of the spheres, ${\bar p}_1$, is on the $x$-axis, thus two of the spheres are collinear. The equations for the three spheres can be rewritten as follows:
\begin{align}
	r_1^2 & =x^2+y^2+z^2 \label{eq:1}\\
	r_2^2 & =(x-d)^2+y^2+z^2 \label{eq:2}\\
	r_3^2 & =(x-i)^2+(y-j)^2+z^2 \label{eq:3}
\end{align}
where $d$ is the distance between sphere centres $p_1$ and $p_2$ and $i$ and $j$ are the signed magnitudes of the $x$ and $y$ components of the vector from $p_1$ to $p_3$. Figure \ref{fig:trilat2} illustrates these components and the positions of the spheres in the $z=0$ plane.

To solve these equations \ref{eq:1}

\begin{figure}[h]
	\begin{center}
		\def\svgwidth{0.6\textwidth}
		\input{figures/trilat2.pdf_tex}
		\caption{Figure showing three intersecting spheres in the plane containing their centres. Figure from \cite{Wikipedi2013}.}
		\label{fig:trilat2}
	\end{center}
\end{figure}

\subsection{General solution}



\section{Wikipedia Talk}

In general coordinates, three spheres intersect at $(x, \  y, \  z)$ if
\[(x-x_1)^2+(y-y_1)^2+(z-z_1)^2=r_1^2\]
\[(x-x_2)^2+(y-y_2)^2+(z-z_2)^2=r_2^2\]
\[(x-x_3)^2+(y-y_3)^2+(z-z_3)^2=r_3^2\]
but it is rather hard to solve these three equations directly.

To simplify the problem, define basis vectors
\[ \hat{e_x} = \frac{\bar{p}_2 - \bar{p}_1}{\lVert \bar{p}_2 - \bar{p}_1 \rVert}, \ 
\hat{e_y} = \frac{({\bar p}_3 - {\bar p}_1) - \hat e_x ( \hat e_x \cdot ( {\bar p}_3 - {\bar p}_1 ) )}{\lVert ({\bar p}_3 - {\bar p}_1) - \hat e_x ( \hat e_x \cdot ( {\bar p}_3 - {\bar p}_1 ) )\rVert}, \  
\hat e_z = \hat e_x \times \hat e_y\]
to represent the axes of a new coordinate system.
(Because there are only three points, the system is essentially planar, and we do not need the third axis, ${\hat e_z}$, yet.)

In this new coordinate system, you can write the three points as
\[{\bar p}_1 = (x_1, y_1, z_1)\]
\[{\bar p}_2 = (x_2, y_2, z_2) = {\bar p}_1 + \hat e_x h\]
\[{\bar p}_3 = (x_3, y_3, z_3) = {\bar p}_1 + \hat e_x i + \hat e_y j\]
where
\[h = \hat e_x \cdot ({\bar p}_2 - {\bar p}_1) = \lVert {\bar p}_2 - {\bar p}_1 \rVert\]
\[i = \hat e_x \cdot ({\bar p}_3 - {\bar p}_1)\]
\[j = \hat e_y \cdot ({\bar p}_3 - {\bar p}_1)\]

If $h = 0$, the first two spheres are concentric, and there can be no solution. (If the two first spheres have different radii, they cannot intersect at all. If they have the same radii, they are the same sphere.)

If $j = 0$, the three spheres are in line. (Oops, I guess there are two possible intersection points, ${\bar p}_1 \pm r_1 {\hat e}_x$, one of which may be a valid solution. I overlooked this earlier, and the test program below does not check these.)

One should probably reorder the spheres to maximise $min(h, |j|)$ to get a good numerical stability and accuracy. See the end of this section for the reasoning. Note that reordering the spheres does not change the result (other than via numerical stability and accuracy); just remember to reorder both the points and the radii the same way.

Using the three variables $h$, $i$, and $j$, with ${\bar p}_1$ at the origin,
the system of three equations can now be written as
\[X^2 + Y^2 + Z^2 = r_1^2\]
\[(X - h)^2 + Y^2 + Z^2 = r_2^2\]
\[(X - i)^2 + (Y - j)^2 + Z^2 = r_3^2\]
and the point we are looking for is $(x,y,z) = {\bar p}_1 + \hat e_x X + \hat e_y Y + \hat e_z Z$ in this coordinate system.

As promised, the above system of three equations is easy to solve. Subtract the second equation from the first, and solve for $X$ to get
\[X = \frac{r_1^2 - r_2^2 + h^2}{2 h}\]
Then, subtract the third equation from the first, and solve for $Y$ to get
\[Y = \frac{r_1^2 - r_3^2 + i^2 + j^2 - 2 i X}{2 j}\]
and then, using the first equation, solve for $Z$ to get
\[Z = \pm \sqrt{r_1^2 - X^2 - Y^2}\]

In the original coordinates, the solution is
\[\bar p = {\bar p}_1 + \hat e_x X + \hat e_y Y \pm \hat e_z Z\]

Some considerations for when solutions may not exist, and when errors are large:

If $h = 0$, the first two spheres are concentric. If $r_1 = r_2$, they are the same sphere, so there are really just two spheres.

If ${\bar p}_1$ and ${\bar p}_2$ are very close to each other, $h$ is very small, and any errors in the input values are magnified in $X$.

If ${\bar p}_1$, ${\bar p}_2$ and ${\bar p}_3$ are on the same line, $j$ will be zero. One of ${\bar p}_1 \pm {\hat e}_x r_1$ might be a solution. If angle ${\bar p}_2{\bar p}_1{\bar p}_3$ is small or near 180 degrees, the correction term for basis vector $\hat e_y$ is large, and therefore $j$ very small compared to $i$; any errors in the input values are magnified in $Y$.

Because the order of the spheres is the only free variable (to maximise accuracy and stability with), and there are only six possible combinations, it should be enough to make sure neither $h$ nor $|j|$ are very small; selecting the order which gives the largest $min(h, |j|)$ does that. Error analysis on the equations above would show if maximising $min(h,|j|)$ gives the best accuracy and numerical stability; in any case, that choice is never particularly susceptible to numerical errors because neither $h$ nor $|j|$ are small.


\section{Wikipedia Main}

The intersections of the surfaces of three spheres is found by formulating the equations for the three sphere surfaces and then solving the three equations for the three unknowns, ''x'', ''y'', and ''z''. To simplify the calculations, the equations are formulated so that the centres of the spheres are on the ''z'' = 0 plane.  Also the formulation is such that one centre is at the origin, and one other is on the ''x''-axis. It is possible to formulate the equations in this manner since any three non-collinear points lie on a unique plane.  After finding the solution it can be transformed back to the original three dimensional [[Cartesian coordinate system]].

We start with the equations for the three spheres:

\[r_1^2=x^2+y^2+z^2 \,\]

\[r_2^2=(x-d)^2+y^2+z^2 \,\]

\[r_3^2=(x-i)^2+(y-j)^2+z^2 \,\]

We need to find a point located at (''x'', ''y'', ''z'') that satisfies all three equations.

First we subtract the second equation from the first and solve for ''x'':

\[x=\frac{r_1^2-r_2^2+d^2}{2d}.\]

We assume that the first two spheres intersect in more than one point, that is that

\[d-r_1 < r_2 < d+r_1. \,\]

In this case substituting the equation for ''x'' back into the equation for the first sphere produces the equation for a circle, the solution to the intersection of the first two spheres:

\[y^2+z^2=r_1^2-\frac{(r_1^2-r_2^2+d^2)^2}{4d^2}.\]
<!-- Setting this formula equal to the formula for the third sphere finds: -->

Substituting $z^2=r_1^2-x^2-y^2$ into the formula for the third sphere and solving for ''y'' there results:

\[y=\frac{r_1^2-r_3^2-x^2+(x-i)^2+j^2}{2j}=\frac{r_1^2-r_3^2+i^2+j^2}{2j}-\frac{i}{j}x.\]

Now that we have the ''x''- and ''y''-coordinates of the solution point, we can simply rearrange the formula for the first sphere to find the ''z''-coordinate:

\[z=\pm \sqrt{r_1^2-x^2-y^2}.\]

Now we have the solution to all three points ''x'', ''y'' and ''z''. Because ''z'' is expressed as the positive or negative square root, it is possible for there to be zero, one or two solutions to the problem.

This last part can be visualized as taking the circle found from intersecting the first and second sphere and intersecting that with the third sphere.  If that circle falls entirely outside or inside of the sphere, ''z'' is equal to the [[Imaginary number|square root of a negative number]]: no real solution exists. If that circle touches the sphere on exactly one point, ''z'' is equal to zero. If that circle touches the surface of the sphere at two points, then ''z'' is equal to plus or minus the square root of a positive number. <!-- If there is no solution, there is no solution. Furthermore one sphere surface is at a distance of r1 from (0,0) so there appears to be no basis for saying zero is the nearest solution. --> <!-- In the case of no solution, a not uncommon one when using [[noisy data]], the nearest solution is zero.  One should be careful, though, to do a [[sanity check]] and assume zero only when the error is appropriately small. --> <!-- Trilateration is a mathematical method for finding the intersection of 3 sphere surfaces.  It is purely mathematical and in no way depends on GPS.  The comment below is inappropriate in an article on trilateration. --><!-- In the case of two solutions, some technique must be used to disambiguate between the two.  This can be done mathematically, by using a fourth sphere with its center not being located on the same plane as the centers of the other three, and determining which point lies closest to the surface of this sphere. Or it can be done logically—for example, [[Global Positioning System|GPS receivers]] assume that the point that lies inside the orbit of the satellites is the correct one when faced with this ambiguity, because it is generally safe to assume that the user is never in space, outside the satellites' orbits. -->

== Preliminary and final computations ==

The ''Derivation'' section pointed out that the coordinate system in which the sphere centers are designated must be such that (1) all three centers are in the plane ''z'' = 0, (2) the sphere center, ''P''1, is at the origin, and (3) the sphere center, ''P''2, is on the ''x''-axis.  In general the problem will not be given in a form such that these requirements are met.

This problem can be overcome as described below where the points, ''P''1, ''P''2, and ''P''3 are treated as vectors from the origin where indicated.  ''P''1, ''P''2, and ''P''3 are of course expressed in the original coordinate system.
\[\hat e_x = \frac{ P2 - P1 }{ \| P2 - P1 \| }\] is the unit vector in the direction from ''P''1 to ''P''2.
\[i = \hat e_x \cdot ( P3 - P1 )\] is the signed magnitude of the ''x'' component, in the figure 1 coordinate system, of the vector from ''P''1 to ''P''3.
\[\hat e_y = \frac{ P3 - P1 - i \; \hat e_x}{ \| P3 - P1 - i \; \hat e_x \| }\] is the unit vector in the y direction.  Note that the points ''P''1, ''P''2, and ''P''3 are all in the ''z'' = 0 plane of the figure 1 coordinate system.
The third basis unit vector is $\hat e_z = \hat e_x \times \hat e_y$. Therefore,
\[d = \| P2 - P1 \|\] the distance between the centers ''P''1 and ''P''2 and
\[j = \hat e_y \cdot ( P3 - P1 )\] is the signed magnitude of the y component, in the figure 1 coordinate system, of the vector from ''P''1 to ''P''3.
Using $i, \;  d$  and  $j$ as computed above, solve for ''x'', ''y'' and ''z'' as described in the ''Derivation'' section. Then

\[\vec p_{1,2} = P1 + x \ \hat e_x + y \ \hat e_y \ \pm \ z \ \hat e_z\]

gives the points in the original coordinate system since $\hat e_x, \; \hat e_y$ and $\hat e_z$, the basis unit vectors, are expressed in the original coordinate system.


\section{Project progress}

I implemented a basic version of trilateration which I will test and extend
tomorrow so that it handles cases when the positions of the reader nodes
vary. It runs in a separate thread and is in a separate class.

 I implemented a full version of trilateration. It takes 3 reader positions
and their radii as an input and returns a position of the tag if there exists
one. The algorithm handles cases such as 2 of the readers being concen-
tric (having the same centre/position), 3 readers being collinear. In some
cases, there aren’t any existing solutions but that is reflected in the pro-
gramme.

Updated the trilateration algorithm so that it can read the reader positions
from the database if they are changed through the web interface.


\section{Summary}

iteration, design, systematic approach, decisions, resolving problems, 
