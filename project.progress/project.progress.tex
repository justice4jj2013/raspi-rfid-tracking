\documentclass[a4paper,12pt]{article}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}
\usepackage[colorlinks=true, citecolor=black, linkcolor=black, urlcolor=black, bookmarks]{hyperref}

\lstset{language=PHP, numbers=left, stepnumber=1}

\begin{document}

\title{Project Progress}
\date{\today}
\author{Aleksandar Krastev (s0833784)}
\maketitle


\section{June 16, Sunday}

\begin{itemize}
	\item Downloaded Raspbian Linux. It is a flavour of Debian Linux that is optimised for the Raspberry Pi. Its packets are compiled to use hard floating point arithmetic because the Raspberry Pi does not have floating point hardware to bring costs down. The operating system's image was downloaded from \url{http://www.raspberrypi.org/downloads}.
	\item Followed instruction at \url{http://elinux.org/RPi_Easy_SD_Card_Setup#Using_the_Linux_command_line} to install an operating system on the 3 SD cards.
\end{itemize} 

\section{June 17, Monday}

\begin{itemize}
	\item Tested the 3 Raspberry Pi that their operating systems booted and ran as expected. Updated the systems and expanded the SD card partitions to fill the entire space on the SD cards (3.9Gb). Renamed the hostnames of the devices pi0, pi1, pi2. Marked the devices and SD cards with numbers 0, 1, and 2.
	\item Connected the 3 devices to a switch (given to me by my flatmate). Then connected the switch to the our flat's broadband ADSL router. I reserved the following IP addresses for the devices - 192.168.1.10, 192.168.1.11, 192.168.1.12 - using the RasPi's MAC addresses for identification. The devices successfully connected to the router and were assigned their reserved IP addresses. They could ping websites ( internet connection ) and could ping each other ( local connectivity ).
	\item Installed a web server (apache2), PHP (php5), and an SQL database (sqlite3) on pi2. The web server was running successfully and could be assessed through the LAN (Local Area Network).
	\item The idea is to code in Python to store data in a sqlite database that could be accessed by PHP to display data on the website that could be accessed remotely. Further plans include setting parameters through the website so that they could affect the remote system. Have to think about (explicit) transactions in the database so that both sides of the system can read/write without race conditions or data corruption, i.e. need to find means for synchronisation.
	\item Wrote a small PHP script that could be found at \url{192.168.1.12/status2.php} on the LAN and runs on pi2. The script does checks if the a SSH socket (number 22) can be opened on all three devices and displays if the devices are ON or OFF at the web page.
\begin{lstlisting}
<?php
$pis = array(
	'192.168.1.10',
	'192.168.1.11',
	'192.168.1.12'
);
$data = '<html><body>';
for ($i = 0; $i < count($pis); $i++) {
	$sock = @fsockopen($pis[$i], 22, $errno, $errstr, 1);
	if ($sock) {
		$data .= '<p>pi'.$i.': ON</p>';
		fclose($sock);
	} else {
		$data .= '<p>pi'.$i.': OFF</p>';
	}
}
$data .= '</body></html>';
echo $data;
?>
\end{lstlisting}
	\item Created an image of the current configuration of the pi2 (working OS with web server) so that if something goes wrong the system can be restored fast. Compressed the image (using xz) so that it takes less space.
	\item Applied for a free Student Micro Account (5 private repositories) on GitHub. My account was upgraded and I created a private repository for my project at \url{https://github.com/sandio/raspi-rfid-tracking} (not accessible because it is a private repository). If Michael Rovatsos or Michael Anslow have profiles at GitHub can add them as collaborators. This repository will be used by me to record any progress made as well as to write my thesis. I think it is a good place because I can record different versions of my work. The repository will be used by the RasPis also. It will contain the source code of the project. Any changes will be documented and committed to the GitHub server so that all devices and collaborators have the most recent version of the project. I plan to tag a bundle of source code changes into versions (eg. v0.1) so that the project progresses through versions with added functionality or fixed bugs. I plan to use GitHub's issue tracker in order to record bugs and my feature requests.
\end{itemize}

\section{June 18, Tuesday}

\begin{itemize}
	\item Created this project progress document.
	\item Came up with an idea that all devices can run the same setup. More specifically, each device will get data from its neighbours and compute a possible position. After 3 positions are computed independently one RasPi can act as an arbiter to decide which is the most probable position. This idea can be applied once one device can compute the tag's position based on the distance readings of the 3 RasPis.
	\item Read and highlighted "An Introduction to RFID Technology" by Roy Want \cite{Want2006}. It is good introductory article that clearly explains different classifications of RFID. It has helpful graphics for the distinction between near and far field RFID communication.
\end{itemize}

\section{June 19, Wednesday}

\begin{itemize}
	\item Read and highlighted "RFID Tags: Positioning Principles and Localization Techniques" by Mathieu Bouet \cite{Bouet2008}. Contains similar introduction to RFID technology. Explains the role of the server (RasPi in our case) connected to the readers that runs a localisation algorithm and provides the middleware for communication between servers. Contains a good classification of indoor localisation algorithms - distance estimation, scene analysis, and proximity. A brief but clear explanation of lateration with a useful figure. Contains a classification of range measurements techniques starting with Received Signal Strength (RSS) that will be used in this project. "The attenuation (gradual loss) of emitted signal strength is a function of the distance between the emitter and the receiver."
	
	A classification of different RFID localisation schemes is proposed. The first one is SpotON where multiple readers collect RSS measurements in order to approximate distance from the tag. Then lateration is performed to localise the tag. 
	
	Landmarc is another approach that uses reference tags that are regularly deployed on the covered area. The idea here is to select the k nearest reference tags that are closest to the unknown tag using differences in RSS measurements. Having identified the k nearest reference tags their coordinates are used to localise the unknown tag. 
	
	VIRE extends the methods used in Landmarc by defining a proximity map that every reader records. This proximity map consists of a 2D grid of reference tags where the centre of a cell is a tag. The difference in the RSS measurements between reference and unknown tag helps label cells in the proximity map so that it can be constructed. The union of individual proximity maps gives a global proximity map for the unknown tag.
	
	Simplex is a method that requires different transmission power levels. I am not sure if our equipment has this feature.
	
	A Kalman filtering method is briefly explained but have to read the original paper because it is hard to understand from a one paragraph description of the method.
	
	Scout is a probabilistic localisation technique that uses a probabilistic RSS model to estimate distances from a tag to readers. Predicted beliefs are calculated and corrected using reference tags until a good model is constructed.

	\item Read and highlighted "Semantic Sensor Net: An Extensible Framework" by Lionel Ni \cite{Ni2005}. It is more concerned with sensor networks with multiple nodes, where the nodes have less importance than traditional computer networks. The article proposes an extensible framework for sensor networks that relies on attaching semantics (meanings) to sensor data but also to sensor nodes, location, context, and queries. The idea is to attach a meaning to every piece of information so that those meanings can be used by the network to route and aggregate data more efficiently, for example. This paper does not have a direct connection to this project but gives grounds for thoughts about attaching meaning to measurements, considering heterogeneous RFID reader nodes, and taking scalability into account.
	
\end{itemize}

\section{June 20, Thursday}

\begin{itemize}
	\item Read and highlighted "SpotON: An Indoor 3D Location Sensing Technology Based on RF Signal Strength" \cite{Hightower2000}. It is a fine-grained tagging technology for 3D location sensing using radio signal strength analysis. They tried to develop a low cost system compared to commercial solutions available at their time. They believe that the accuracy and efficiency of location sensing could be enhanced by sensor fusion, i.e. adding more sensors (accelerometers) and building maps. These authors talk about ubiquitous computing. They try to separate the meanings of positioning and tracking. Positioning is concerned with providing means to calculate location which can be used to compute an actual position. Tracking is monitoring objects without involving them in the computation. They define location sensing to be such systems that separate the manipulation of location data from the mechanisms of actually pinpointing the objects. They used radio devices with a serial connection similar to the devices that will be used in this project. They were talking about the limitations of such a serial connection (R232) which will mitigated in our case by using a converter from serial to USB. In our case base stations that aggregate information and a server that processes it is combined into the Raspberry Pi computer. 
	
	This paper summarises the localisation algorithm they used based on the conversion of distance into signal strength in 6 directions in 3D. Then the measured RSS is compared to the 6 known RSS to find a location around a reader. They do not store data or timing information on the server, which I am planning to do. They have a visualisation client written in OpenGL. 
	
	Their results are not very accurate because they use radio devices with 2-bit RSS accuracy compared to modern onces with 8-bit accuracy. Their second problem was measurement frequency which happened between 10 to 20 seconds, which is too slow to monitor real-time position changes of objects. They identified these limitations and solved them by creating a custom hardware.
	
	\item Individual meeting with Michael Rovatsos and Michael Anslow. Discussed that the RFID equipment is arriving next week. Discussed the GitHub repository for the project. Discussed that until the equipment arrives parts of the thesis can be written (currently reading important papers for the Related Work section). Discussed how the processing could be spread in later stages. Discussed that the project should be written in such a way that it could be used on other platforms, for instance on a laptop running Linux. Decided to meet again on the 1st of July at 17:00 on Skype.
	
\end{itemize}

\section{June 21, Friday}

\begin{itemize}
	\item Read and highlighted "LANDMARC: Indoor Location Sensing Using Active RFID" \cite{Ni2004}. LANDMARC is a location sensing system that uses RFID for locating objects inside buildings. Its major advantage is that it improves the overall accuracy of locating objects by using reference tags. They believe that the choice of technology and techniques is of crucial importance for the granularity and accuracy of the location information. They identify that range of a RFID system is determined by the power available at readers and tags and the environmental conditions and structures. In free space, the signal strength reduces in inverse proportion to the square of the distance. They found out that instead of using a lot of readers, they can arrange a number of tags in a 2D rectangular grid to use as reference tags. They associate reference tags with landmarks that help navigation in a city, for example. The advantage is that tags are cheaper and are subject to the same environmental factors as the tags being tracked. The authors believe that the placement of readers and reference tags is very important for the accuracy of the system. They needed an algorithm to connect the relationships between signal strengths and power levels that the readers return.
	
	Their setup consists of RF tags and readers with a wireless module for communicating measurements to a location server. Their methodology is explained very good in their paper and relies on Euclidean distance between reference tags and unknown tags and also on k nearest neighbours to pinpoint a possible position. They apply a weighing factor when computing coordinates. To measure the accuracy of the system error distance is used. It is the linear distance between real coordinates and computed coordinates.
	
	They discuss different parameters of the system. First, they found through experimentation that 4 nearest neighbours provide the best results during most of their tests. They also acknowledge the environmental factors night vs. day tests, change of placement of the tracking tags. They have restricted the number of readers used but point out that more readers provide better accuracy in certain cases. The LANDMARC system is based on reference tags so the authors discuss in detail the placement and number of the reference tags. They argue that density of reference tags plays an important role for the accuracy of the system. A good setup, they used, was consisting of 4 readers and 1 reference tag per square meter resulting in an average distance error of 1 meter.
	
	Back in 2004 when the paper was written, the authors identified the hardware problems of the current RFID technology. None of RFID products supplied signal strength directly which requires unnecessary processing and sacrifice of accuracy. They also were complaining about the long latency between actual placement of tracking tags and the system computing their location. Two factors were contributing to this problem. One being the scanning time of the readers, not supporting RSS. The second the time interval of a tag emitting its ID, which is not a configurable parameter. They also identified different power levels detected by a reader from two tags which resulted in variation in their behaviour. 
\end{itemize}

\section{June 22, Saturday}

\begin{itemize}
	\item Read and highlighted "Location Estimation Technique using Extended 3-D LANDMARC Algorithm for Passive RFID Tag" \cite{Khan2009}. It is an extension of LANDMARC for 3D. They used passive instead of active tags. They use RSSI which is availble from the readers they used instead of computing it from power levels. The error rate they recorded was 0.5m when estimating location. The authors explain what RSS is and summarise relationships between RSS values and distance metrics for outdoor and indoor environments. They explain that RSS measurements may suffer from multi-path fading, shadowing, diffraction, reflection, and scattering. They explain what scene analysis (finger printing) is and the two phases it consists of (offline and online). They summarise the main methods used with scene analysis: probabilistic, kNN, and neural networks. They use the same methodology as the original LANDMARC system but extend it to 3D, adding 'z' coordinate. For their experiments they used 3 readers, 2 tracking tags, and 11 reference tags. They supply all their intermediate and final results in tables with computed values for RSS tag vectors, Euclidean distance between reference and tracking tags, weights for every distance, reference tags coordinates, and estimated tracking tag's coordinates.
\end{itemize}

\section{June 24, Monday}

\begin{itemize}
	\item Read and highlighted "Guidelines for MSc/Diploma Projects and Dissertations MSc in Artificial Intelligence".
	\item Read and highlighted "Peter's Project Guide" by Peter Ross.
	\item The rest of the equipment arrived. This includes 3 RFID readers and an active RFID tag. The readers output through a serial port (R232) which is connected to a serial to USB converter. The tag arrived without the included battery (CR2025). The tag arrived with no antenna ( a piece of 8mm thick, 2cm long copper wire). The tag transmits its ID every 2.5 seconds with an offset of 0.5 seconds according to the manufacturer. With the battery I got a standard CR2032, the manufacturer claims an active tag could last up to 7,000 operating hours.
	\item I connected one of the readers to my laptop. I used \textsf{gtkterm} ( a GTK serial communication terminal) and \textsf{minicom} (a command-line communication terminal). A serial connection to any of the readers should be configured to use a \textsc{baudrate=9600, bytesize=8, parity=None, stopbits=1}, and both software and hardware flow control turned \textsc{off}.
	\item With the above fairly standard settings, the reader was receiving data from the active tag, although the tag was lacking an antenna. I decided to solder an antenna (a piece of wire). The antenna that was attached was around 10cm wire which was consisting of a number of individual smaller copper cores. The reader could only receive when I was holding the tag's antenna. Maybe there is some kind of interference with this antenna, maybe its the thickness, length, insides of the wire, I don't really know.
	\item I removed this piece of wire and the tag was at its original state. I will look for a better piece of wire to act as an antenna when I do RSSI measurement experiments.
	\item The 3 readers were connected to the 3 Raspberry Pis. They successfully detected the readers and had sufficient USB power to power them properly. This is indeed a very good thing to happen because I was expecting that there won't be sufficient power fed to the readers through the Raspberry Pis' integrated USB hub. Another great thing is that the reader devices were immediately recognised and do not require a driver or a transfer protocol. The readers transmit a 4-byte ID concatenated with a RSS value ranging from 0 to 255 according to the specifications. As mentioned above, the actual values of the RSS will be experimentally tested when an good antenna is installed (not that I know what a good antenna in this case is).
	\item I installed \textsf{pyserial} \textsc{Python} module on all Pis. I wrote a simple serial python programme that connects to a reader device and checks that the port is open and that the device is truly the one that was specified. It then reads 7 bytes at a time, which is the 4 bytes for ID, 2bytes for RSS, and a space character. It strips the string off the space character and displaces the rest until the input buffer is depleted. At this point, a read request is blocking the programme until another piece of data comes from the reader. This, however, is not a good practice because an RSS value could be a single byte (showing readings from 0-9), a two-byte value (10-99), and three-byte value (100-255). As a result, reading 7 bytes of data works when the RSS measurements are from 10 to 99.
\end{itemize}

\section{June 25, Tuesday}

\begin{itemize}
	\item There are two annoying issues with the data coming from the readers. First, the RSS values are received in a non-fixed length field, meaning they arrive concatenated to the tag's ID: 1, 11, 111 instead of 001, 011, 111. Second, the ID + RSS string is separated from the next and previous one by a space character instead of a newline character \textbackslash{}n, or a carriage return \textbackslash{}r, or both \textbackslash{}r\textbackslash{}n. All these are standard and \textsf{pyserial} has a \textsf{readline()} function that neatly parses the input and returns when a new line arrives from the reader. Instead both there issues create parsing problems for me, which I solved by reading byte by byte the incoming data until I meet a space, but I am concerned for the performance/speed of my method. However, I have not noticed any considerable delay.
	\item I started expanding my test programme into a class for establishing a serial connection to the readers from the Pis. I believe every class I create should be modular and should abstract away from the specifics of the \textsf{pyserial} module, albeit its simplicity. All my code is and will be commented and committed to the \textsc{GitHub} repository.
	\item I am currently refreshing my \textsc{Python} skills and coding conventions to be able to write code consistently  and to aid reading.
\end{itemize}

\newpage
\bibliographystyle{apalike}
\bibliography{../library}

\end{document}
